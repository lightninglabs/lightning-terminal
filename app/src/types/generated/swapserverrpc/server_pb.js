/* eslint-disable */
var proto = { looprpc: {} };

// source: swapserverrpc/server.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof window !== 'undefined' && window) ||
    (typeof global !== 'undefined' && global) ||
    (typeof self !== 'undefined' && self) ||
    (function () { return this; }).call(null) ||
    Function('return this')();

var swapserverrpc_common_pb = require('../swapserverrpc/common_pb.js');
goog.object.extend(proto, swapserverrpc_common_pb);
var swapserverrpc_reservation_pb = require('../swapserverrpc/reservation_pb.js');
goog.object.extend(proto, swapserverrpc_reservation_pb);
goog.exportSymbol('proto.looprpc.CancelLoopOutSwapRequest', null, global);
goog.exportSymbol('proto.looprpc.CancelLoopOutSwapRequest.CancelInfoCase', null, global);
goog.exportSymbol('proto.looprpc.CancelLoopOutSwapResponse', null, global);
goog.exportSymbol('proto.looprpc.FetchL402Request', null, global);
goog.exportSymbol('proto.looprpc.FetchL402Response', null, global);
goog.exportSymbol('proto.looprpc.HtlcAttempt', null, global);
goog.exportSymbol('proto.looprpc.MuSig2SignSweepReq', null, global);
goog.exportSymbol('proto.looprpc.MuSig2SignSweepRes', null, global);
goog.exportSymbol('proto.looprpc.PaymentFailureReason', null, global);
goog.exportSymbol('proto.looprpc.PrevoutInfo', null, global);
goog.exportSymbol('proto.looprpc.ProtocolVersion', null, global);
goog.exportSymbol('proto.looprpc.RecommendRoutingPluginReq', null, global);
goog.exportSymbol('proto.looprpc.RecommendRoutingPluginRes', null, global);
goog.exportSymbol('proto.looprpc.ReportRoutingResultReq', null, global);
goog.exportSymbol('proto.looprpc.ReportRoutingResultRes', null, global);
goog.exportSymbol('proto.looprpc.RouteCancel', null, global);
goog.exportSymbol('proto.looprpc.RoutePaymentType', null, global);
goog.exportSymbol('proto.looprpc.RoutingPlugin', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopInQuoteRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopInQuoteResponse', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopInRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopInResponse', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopInTerms', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopInTermsRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutPushPreimageRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutPushPreimageResponse', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutQuote', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutQuoteRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutResponse', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutTerms', null, global);
goog.exportSymbol('proto.looprpc.ServerLoopOutTermsRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerProbeRequest', null, global);
goog.exportSymbol('proto.looprpc.ServerProbeResponse', null, global);
goog.exportSymbol('proto.looprpc.ServerPushKeyReq', null, global);
goog.exportSymbol('proto.looprpc.ServerPushKeyRes', null, global);
goog.exportSymbol('proto.looprpc.ServerStaticLoopInSweepNotification', null, global);
goog.exportSymbol('proto.looprpc.ServerSwapState', null, global);
goog.exportSymbol('proto.looprpc.ServerUnfinishedSwapNotification', null, global);
goog.exportSymbol('proto.looprpc.SubscribeLoopInUpdatesResponse', null, global);
goog.exportSymbol('proto.looprpc.SubscribeLoopOutUpdatesResponse', null, global);
goog.exportSymbol('proto.looprpc.SubscribeNotificationsRequest', null, global);
goog.exportSymbol('proto.looprpc.SubscribeNotificationsRequest.ListenerVersion', null, global);
goog.exportSymbol('proto.looprpc.SubscribeNotificationsResponse', null, global);
goog.exportSymbol('proto.looprpc.SubscribeNotificationsResponse.NotificationCase', null, global);
goog.exportSymbol('proto.looprpc.SubscribeUpdatesRequest', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutRequest.displayName = 'proto.looprpc.ServerLoopOutRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutResponse.displayName = 'proto.looprpc.ServerLoopOutResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutQuoteRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutQuoteRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutQuoteRequest.displayName = 'proto.looprpc.ServerLoopOutQuoteRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutQuote = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutQuote, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutQuote.displayName = 'proto.looprpc.ServerLoopOutQuote';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutTermsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutTermsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutTermsRequest.displayName = 'proto.looprpc.ServerLoopOutTermsRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutTerms = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutTerms, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutTerms.displayName = 'proto.looprpc.ServerLoopOutTerms';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopInRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopInRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopInRequest.displayName = 'proto.looprpc.ServerLoopInRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopInResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopInResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopInResponse.displayName = 'proto.looprpc.ServerLoopInResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopInQuoteRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.looprpc.ServerLoopInQuoteRequest.repeatedFields_, null);
};
goog.inherits(proto.looprpc.ServerLoopInQuoteRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopInQuoteRequest.displayName = 'proto.looprpc.ServerLoopInQuoteRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopInQuoteResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopInQuoteResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopInQuoteResponse.displayName = 'proto.looprpc.ServerLoopInQuoteResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopInTermsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopInTermsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopInTermsRequest.displayName = 'proto.looprpc.ServerLoopInTermsRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopInTerms = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopInTerms, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopInTerms.displayName = 'proto.looprpc.ServerLoopInTerms';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutPushPreimageRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutPushPreimageRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutPushPreimageRequest.displayName = 'proto.looprpc.ServerLoopOutPushPreimageRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerLoopOutPushPreimageResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerLoopOutPushPreimageResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerLoopOutPushPreimageResponse.displayName = 'proto.looprpc.ServerLoopOutPushPreimageResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.SubscribeUpdatesRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.SubscribeUpdatesRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.SubscribeUpdatesRequest.displayName = 'proto.looprpc.SubscribeUpdatesRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.SubscribeLoopOutUpdatesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.SubscribeLoopOutUpdatesResponse.displayName = 'proto.looprpc.SubscribeLoopOutUpdatesResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.SubscribeLoopInUpdatesResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.SubscribeLoopInUpdatesResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.SubscribeLoopInUpdatesResponse.displayName = 'proto.looprpc.SubscribeLoopInUpdatesResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.RouteCancel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.looprpc.RouteCancel.repeatedFields_, null);
};
goog.inherits(proto.looprpc.RouteCancel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.RouteCancel.displayName = 'proto.looprpc.RouteCancel';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.HtlcAttempt = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.HtlcAttempt, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.HtlcAttempt.displayName = 'proto.looprpc.HtlcAttempt';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.CancelLoopOutSwapRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.looprpc.CancelLoopOutSwapRequest.oneofGroups_);
};
goog.inherits(proto.looprpc.CancelLoopOutSwapRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.CancelLoopOutSwapRequest.displayName = 'proto.looprpc.CancelLoopOutSwapRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.CancelLoopOutSwapResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.CancelLoopOutSwapResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.CancelLoopOutSwapResponse.displayName = 'proto.looprpc.CancelLoopOutSwapResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerProbeRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.looprpc.ServerProbeRequest.repeatedFields_, null);
};
goog.inherits(proto.looprpc.ServerProbeRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerProbeRequest.displayName = 'proto.looprpc.ServerProbeRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerProbeResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerProbeResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerProbeResponse.displayName = 'proto.looprpc.ServerProbeResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.RecommendRoutingPluginReq = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.RecommendRoutingPluginReq, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.RecommendRoutingPluginReq.displayName = 'proto.looprpc.RecommendRoutingPluginReq';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.RecommendRoutingPluginRes = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.RecommendRoutingPluginRes, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.RecommendRoutingPluginRes.displayName = 'proto.looprpc.RecommendRoutingPluginRes';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ReportRoutingResultReq = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ReportRoutingResultReq, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ReportRoutingResultReq.displayName = 'proto.looprpc.ReportRoutingResultReq';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ReportRoutingResultRes = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ReportRoutingResultRes, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ReportRoutingResultRes.displayName = 'proto.looprpc.ReportRoutingResultRes';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.MuSig2SignSweepReq = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.looprpc.MuSig2SignSweepReq.repeatedFields_, null);
};
goog.inherits(proto.looprpc.MuSig2SignSweepReq, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.MuSig2SignSweepReq.displayName = 'proto.looprpc.MuSig2SignSweepReq';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.PrevoutInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.PrevoutInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.PrevoutInfo.displayName = 'proto.looprpc.PrevoutInfo';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.MuSig2SignSweepRes = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.MuSig2SignSweepRes, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.MuSig2SignSweepRes.displayName = 'proto.looprpc.MuSig2SignSweepRes';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerPushKeyReq = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerPushKeyReq, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerPushKeyReq.displayName = 'proto.looprpc.ServerPushKeyReq';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerPushKeyRes = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerPushKeyRes, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerPushKeyRes.displayName = 'proto.looprpc.ServerPushKeyRes';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.FetchL402Request = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.FetchL402Request, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.FetchL402Request.displayName = 'proto.looprpc.FetchL402Request';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.FetchL402Response = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.FetchL402Response, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.FetchL402Response.displayName = 'proto.looprpc.FetchL402Response';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.SubscribeNotificationsRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.SubscribeNotificationsRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.SubscribeNotificationsRequest.displayName = 'proto.looprpc.SubscribeNotificationsRequest';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.SubscribeNotificationsResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.looprpc.SubscribeNotificationsResponse.oneofGroups_);
};
goog.inherits(proto.looprpc.SubscribeNotificationsResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.SubscribeNotificationsResponse.displayName = 'proto.looprpc.SubscribeNotificationsResponse';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerStaticLoopInSweepNotification = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.looprpc.ServerStaticLoopInSweepNotification.repeatedFields_, null);
};
goog.inherits(proto.looprpc.ServerStaticLoopInSweepNotification, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerStaticLoopInSweepNotification.displayName = 'proto.looprpc.ServerStaticLoopInSweepNotification';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.looprpc.ServerUnfinishedSwapNotification = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.looprpc.ServerUnfinishedSwapNotification, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.looprpc.ServerUnfinishedSwapNotification.displayName = 'proto.looprpc.ServerUnfinishedSwapNotification';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    receiverKey: msg.getReceiverKey_asB64(),
    swapHash: msg.getSwapHash_asB64(),
    amt: jspb.Message.getFieldWithDefault(msg, 3, "0"),
    swapPublicationDeadline: jspb.Message.getFieldWithDefault(msg, 4, "0"),
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 5, 0),
    expiry: jspb.Message.getFieldWithDefault(msg, 6, 0),
    userAgent: jspb.Message.getFieldWithDefault(msg, 7, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutRequest}
 */
proto.looprpc.ServerLoopOutRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutRequest;
  return proto.looprpc.ServerLoopOutRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutRequest}
 */
proto.looprpc.ServerLoopOutRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setReceiverKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setAmt(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setSwapPublicationDeadline(value);
      break;
    case 5:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setExpiry(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserAgent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getReceiverKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getAmt();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      3,
      f
    );
  }
  f = message.getSwapPublicationDeadline();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      4,
      f
    );
  }
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = message.getUserAgent();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
};


/**
 * optional bytes receiver_key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getReceiverKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes receiver_key = 1;
 * This is a type-conversion wrapper around `getReceiverKey()`
 * @return {string}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getReceiverKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getReceiverKey()));
};


/**
 * optional bytes receiver_key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getReceiverKey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getReceiverKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getReceiverKey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setReceiverKey = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional uint64 amt = 3;
 * @return {string}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getAmt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setAmt = function(value) {
  return jspb.Message.setProto3StringIntField(this, 3, value);
};


/**
 * optional int64 swap_publication_deadline = 4;
 * @return {string}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getSwapPublicationDeadline = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setSwapPublicationDeadline = function(value) {
  return jspb.Message.setProto3StringIntField(this, 4, value);
};


/**
 * optional ProtocolVersion protocol_version = 5;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 5, value);
};


/**
 * optional int32 expiry = 6;
 * @return {number}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setExpiry = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional string user_agent = 7;
 * @return {string}
 */
proto.looprpc.ServerLoopOutRequest.prototype.getUserAgent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutRequest} returns this
 */
proto.looprpc.ServerLoopOutRequest.prototype.setUserAgent = function(value) {
  return jspb.Message.setProto3StringField(this, 7, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    swapInvoice: jspb.Message.getFieldWithDefault(msg, 1, ""),
    prepayInvoice: jspb.Message.getFieldWithDefault(msg, 2, ""),
    senderKey: msg.getSenderKey_asB64(),
    expiry: jspb.Message.getFieldWithDefault(msg, 4, 0),
    serverMessage: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutResponse}
 */
proto.looprpc.ServerLoopOutResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutResponse;
  return proto.looprpc.ServerLoopOutResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutResponse}
 */
proto.looprpc.ServerLoopOutResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSwapInvoice(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPrepayInvoice(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSenderKey(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setExpiry(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setServerMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSwapInvoice();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPrepayInvoice();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getSenderKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getServerMessage();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional string swap_invoice = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getSwapInvoice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutResponse} returns this
 */
proto.looprpc.ServerLoopOutResponse.prototype.setSwapInvoice = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string prepay_invoice = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getPrepayInvoice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutResponse} returns this
 */
proto.looprpc.ServerLoopOutResponse.prototype.setPrepayInvoice = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional bytes sender_key = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getSenderKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes sender_key = 3;
 * This is a type-conversion wrapper around `getSenderKey()`
 * @return {string}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getSenderKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSenderKey()));
};


/**
 * optional bytes sender_key = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSenderKey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getSenderKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSenderKey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopOutResponse} returns this
 */
proto.looprpc.ServerLoopOutResponse.prototype.setSenderKey = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional int32 expiry = 4;
 * @return {number}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopOutResponse} returns this
 */
proto.looprpc.ServerLoopOutResponse.prototype.setExpiry = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional string server_message = 5;
 * @return {string}
 */
proto.looprpc.ServerLoopOutResponse.prototype.getServerMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutResponse} returns this
 */
proto.looprpc.ServerLoopOutResponse.prototype.setServerMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutQuoteRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutQuoteRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutQuoteRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    amt: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    swapPublicationDeadline: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 3, 0),
    expiry: jspb.Message.getFieldWithDefault(msg, 4, 0),
    userAgent: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest}
 */
proto.looprpc.ServerLoopOutQuoteRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutQuoteRequest;
  return proto.looprpc.ServerLoopOutQuoteRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutQuoteRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest}
 */
proto.looprpc.ServerLoopOutQuoteRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setAmt(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setSwapPublicationDeadline(value);
      break;
    case 3:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setExpiry(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserAgent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutQuoteRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutQuoteRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutQuoteRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmt();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getSwapPublicationDeadline();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      2,
      f
    );
  }
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getUserAgent();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional uint64 amt = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.getAmt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest} returns this
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.setAmt = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional int64 swap_publication_deadline = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.getSwapPublicationDeadline = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest} returns this
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.setSwapPublicationDeadline = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};


/**
 * optional ProtocolVersion protocol_version = 3;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest} returns this
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};


/**
 * optional int32 expiry = 4;
 * @return {number}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest} returns this
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.setExpiry = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional string user_agent = 5;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.getUserAgent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuoteRequest} returns this
 */
proto.looprpc.ServerLoopOutQuoteRequest.prototype.setUserAgent = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutQuote.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutQuote.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutQuote} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutQuote.toObject = function(includeInstance, msg) {
  var f, obj = {
    swapPaymentDest: jspb.Message.getFieldWithDefault(msg, 1, ""),
    swapFee: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    swapFeeRate: jspb.Message.getFieldWithDefault(msg, 3, "0"),
    prepayAmt: jspb.Message.getFieldWithDefault(msg, 4, "0"),
    minSwapAmount: jspb.Message.getFieldWithDefault(msg, 5, "0"),
    maxSwapAmount: jspb.Message.getFieldWithDefault(msg, 6, "0"),
    cltvDelta: jspb.Message.getFieldWithDefault(msg, 7, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutQuote}
 */
proto.looprpc.ServerLoopOutQuote.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutQuote;
  return proto.looprpc.ServerLoopOutQuote.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutQuote} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutQuote}
 */
proto.looprpc.ServerLoopOutQuote.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSwapPaymentDest(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setSwapFee(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setSwapFeeRate(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setPrepayAmt(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMinSwapAmount(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMaxSwapAmount(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCltvDelta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutQuote.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutQuote.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutQuote} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutQuote.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSwapPaymentDest();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSwapFee();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      2,
      f
    );
  }
  f = message.getSwapFeeRate();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      3,
      f
    );
  }
  f = message.getPrepayAmt();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      4,
      f
    );
  }
  f = message.getMinSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      5,
      f
    );
  }
  f = message.getMaxSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      6,
      f
    );
  }
  f = message.getCltvDelta();
  if (f !== 0) {
    writer.writeInt32(
      7,
      f
    );
  }
};


/**
 * optional string swap_payment_dest = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getSwapPaymentDest = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setSwapPaymentDest = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional int64 swap_fee = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getSwapFee = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setSwapFee = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};


/**
 * optional int64 swap_fee_rate = 3;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getSwapFeeRate = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setSwapFeeRate = function(value) {
  return jspb.Message.setProto3StringIntField(this, 3, value);
};


/**
 * optional uint64 prepay_amt = 4;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getPrepayAmt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setPrepayAmt = function(value) {
  return jspb.Message.setProto3StringIntField(this, 4, value);
};


/**
 * optional uint64 min_swap_amount = 5;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getMinSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setMinSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 5, value);
};


/**
 * optional uint64 max_swap_amount = 6;
 * @return {string}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getMaxSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setMaxSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 6, value);
};


/**
 * optional int32 cltv_delta = 7;
 * @return {number}
 */
proto.looprpc.ServerLoopOutQuote.prototype.getCltvDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopOutQuote} returns this
 */
proto.looprpc.ServerLoopOutQuote.prototype.setCltvDelta = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutTermsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutTermsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutTermsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutTermsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    userAgent: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutTermsRequest}
 */
proto.looprpc.ServerLoopOutTermsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutTermsRequest;
  return proto.looprpc.ServerLoopOutTermsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutTermsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutTermsRequest}
 */
proto.looprpc.ServerLoopOutTermsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserAgent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutTermsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutTermsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutTermsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutTermsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getUserAgent();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopOutTermsRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopOutTermsRequest} returns this
 */
proto.looprpc.ServerLoopOutTermsRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string user_agent = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopOutTermsRequest.prototype.getUserAgent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutTermsRequest} returns this
 */
proto.looprpc.ServerLoopOutTermsRequest.prototype.setUserAgent = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutTerms.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutTerms.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutTerms} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutTerms.toObject = function(includeInstance, msg) {
  var f, obj = {
    minSwapAmount: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    maxSwapAmount: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    minCltvDelta: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maxCltvDelta: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutTerms}
 */
proto.looprpc.ServerLoopOutTerms.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutTerms;
  return proto.looprpc.ServerLoopOutTerms.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutTerms} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutTerms}
 */
proto.looprpc.ServerLoopOutTerms.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMinSwapAmount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMaxSwapAmount(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinCltvDelta(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxCltvDelta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutTerms.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutTerms.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutTerms} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutTerms.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMinSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getMaxSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      2,
      f
    );
  }
  f = message.getMinCltvDelta();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getMaxCltvDelta();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional uint64 min_swap_amount = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopOutTerms.prototype.getMinSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutTerms} returns this
 */
proto.looprpc.ServerLoopOutTerms.prototype.setMinSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional uint64 max_swap_amount = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopOutTerms.prototype.getMaxSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopOutTerms} returns this
 */
proto.looprpc.ServerLoopOutTerms.prototype.setMaxSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};


/**
 * optional int32 min_cltv_delta = 3;
 * @return {number}
 */
proto.looprpc.ServerLoopOutTerms.prototype.getMinCltvDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopOutTerms} returns this
 */
proto.looprpc.ServerLoopOutTerms.prototype.setMinCltvDelta = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int32 max_cltv_delta = 4;
 * @return {number}
 */
proto.looprpc.ServerLoopOutTerms.prototype.getMaxCltvDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopOutTerms} returns this
 */
proto.looprpc.ServerLoopOutTerms.prototype.setMaxCltvDelta = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopInRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopInRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopInRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    senderKey: msg.getSenderKey_asB64(),
    senderInternalPubkey: msg.getSenderInternalPubkey_asB64(),
    swapHash: msg.getSwapHash_asB64(),
    amt: jspb.Message.getFieldWithDefault(msg, 3, "0"),
    swapInvoice: jspb.Message.getFieldWithDefault(msg, 4, ""),
    lastHop: msg.getLastHop_asB64(),
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 6, 0),
    probeInvoice: jspb.Message.getFieldWithDefault(msg, 7, ""),
    userAgent: jspb.Message.getFieldWithDefault(msg, 8, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopInRequest}
 */
proto.looprpc.ServerLoopInRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopInRequest;
  return proto.looprpc.ServerLoopInRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopInRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopInRequest}
 */
proto.looprpc.ServerLoopInRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSenderKey(value);
      break;
    case 9:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSenderInternalPubkey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setAmt(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setSwapInvoice(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastHop(value);
      break;
    case 6:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setProbeInvoice(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserAgent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopInRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopInRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSenderKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSenderInternalPubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      9,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getAmt();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      3,
      f
    );
  }
  f = message.getSwapInvoice();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getLastHop_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      6,
      f
    );
  }
  f = message.getProbeInvoice();
  if (f.length > 0) {
    writer.writeString(
      7,
      f
    );
  }
  f = message.getUserAgent();
  if (f.length > 0) {
    writer.writeString(
      8,
      f
    );
  }
};


/**
 * optional bytes sender_key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSenderKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes sender_key = 1;
 * This is a type-conversion wrapper around `getSenderKey()`
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSenderKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSenderKey()));
};


/**
 * optional bytes sender_key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSenderKey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSenderKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSenderKey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setSenderKey = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes sender_internal_pubkey = 9;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSenderInternalPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/**
 * optional bytes sender_internal_pubkey = 9;
 * This is a type-conversion wrapper around `getSenderInternalPubkey()`
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSenderInternalPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSenderInternalPubkey()));
};


/**
 * optional bytes sender_internal_pubkey = 9;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSenderInternalPubkey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSenderInternalPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSenderInternalPubkey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setSenderInternalPubkey = function(value) {
  return jspb.Message.setProto3BytesField(this, 9, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional uint64 amt = 3;
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getAmt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setAmt = function(value) {
  return jspb.Message.setProto3StringIntField(this, 3, value);
};


/**
 * optional string swap_invoice = 4;
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getSwapInvoice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setSwapInvoice = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional bytes last_hop = 5;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInRequest.prototype.getLastHop = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes last_hop = 5;
 * This is a type-conversion wrapper around `getLastHop()`
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getLastHop_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastHop()));
};


/**
 * optional bytes last_hop = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastHop()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInRequest.prototype.getLastHop_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastHop()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setLastHop = function(value) {
  return jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional ProtocolVersion protocol_version = 6;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopInRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 6, value);
};


/**
 * optional string probe_invoice = 7;
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getProbeInvoice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setProbeInvoice = function(value) {
  return jspb.Message.setProto3StringField(this, 7, value);
};


/**
 * optional string user_agent = 8;
 * @return {string}
 */
proto.looprpc.ServerLoopInRequest.prototype.getUserAgent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInRequest} returns this
 */
proto.looprpc.ServerLoopInRequest.prototype.setUserAgent = function(value) {
  return jspb.Message.setProto3StringField(this, 8, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopInResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopInResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopInResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    receiverKey: msg.getReceiverKey_asB64(),
    receiverInternalPubkey: msg.getReceiverInternalPubkey_asB64(),
    expiry: jspb.Message.getFieldWithDefault(msg, 2, 0),
    serverMessage: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopInResponse}
 */
proto.looprpc.ServerLoopInResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopInResponse;
  return proto.looprpc.ServerLoopInResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopInResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopInResponse}
 */
proto.looprpc.ServerLoopInResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setReceiverKey(value);
      break;
    case 9:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setReceiverInternalPubkey(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setExpiry(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setServerMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopInResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopInResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getReceiverKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getReceiverInternalPubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      9,
      f
    );
  }
  f = message.getExpiry();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getServerMessage();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional bytes receiver_key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInResponse.prototype.getReceiverKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes receiver_key = 1;
 * This is a type-conversion wrapper around `getReceiverKey()`
 * @return {string}
 */
proto.looprpc.ServerLoopInResponse.prototype.getReceiverKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getReceiverKey()));
};


/**
 * optional bytes receiver_key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getReceiverKey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInResponse.prototype.getReceiverKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getReceiverKey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInResponse} returns this
 */
proto.looprpc.ServerLoopInResponse.prototype.setReceiverKey = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes receiver_internal_pubkey = 9;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInResponse.prototype.getReceiverInternalPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/**
 * optional bytes receiver_internal_pubkey = 9;
 * This is a type-conversion wrapper around `getReceiverInternalPubkey()`
 * @return {string}
 */
proto.looprpc.ServerLoopInResponse.prototype.getReceiverInternalPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getReceiverInternalPubkey()));
};


/**
 * optional bytes receiver_internal_pubkey = 9;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getReceiverInternalPubkey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInResponse.prototype.getReceiverInternalPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getReceiverInternalPubkey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInResponse} returns this
 */
proto.looprpc.ServerLoopInResponse.prototype.setReceiverInternalPubkey = function(value) {
  return jspb.Message.setProto3BytesField(this, 9, value);
};


/**
 * optional int32 expiry = 2;
 * @return {number}
 */
proto.looprpc.ServerLoopInResponse.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopInResponse} returns this
 */
proto.looprpc.ServerLoopInResponse.prototype.setExpiry = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string server_message = 3;
 * @return {string}
 */
proto.looprpc.ServerLoopInResponse.prototype.getServerMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInResponse} returns this
 */
proto.looprpc.ServerLoopInResponse.prototype.setServerMessage = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.looprpc.ServerLoopInQuoteRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopInQuoteRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopInQuoteRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInQuoteRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    amt: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    pubkey: msg.getPubkey_asB64(),
    lastHop: msg.getLastHop_asB64(),
    routeHintsList: jspb.Message.toObjectList(msg.getRouteHintsList(),
    swapserverrpc_common_pb.RouteHint.toObject, includeInstance),
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 2, 0),
    userAgent: jspb.Message.getFieldWithDefault(msg, 6, ""),
    numStaticAddressDeposits: jspb.Message.getFieldWithDefault(msg, 7, 0),
    fast: jspb.Message.getBooleanFieldWithDefault(msg, 8, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopInQuoteRequest}
 */
proto.looprpc.ServerLoopInQuoteRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopInQuoteRequest;
  return proto.looprpc.ServerLoopInQuoteRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopInQuoteRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopInQuoteRequest}
 */
proto.looprpc.ServerLoopInQuoteRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setAmt(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPubkey(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastHop(value);
      break;
    case 5:
      var value = new swapserverrpc_common_pb.RouteHint;
      reader.readMessage(value,swapserverrpc_common_pb.RouteHint.deserializeBinaryFromReader);
      msg.addRouteHints(value);
      break;
    case 2:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserAgent(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumStaticAddressDeposits(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setFast(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopInQuoteRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopInQuoteRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInQuoteRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAmt();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getPubkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getLastHop_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getRouteHintsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      swapserverrpc_common_pb.RouteHint.serializeBinaryToWriter
    );
  }
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getUserAgent();
  if (f.length > 0) {
    writer.writeString(
      6,
      f
    );
  }
  f = message.getNumStaticAddressDeposits();
  if (f !== 0) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = message.getFast();
  if (f) {
    writer.writeBool(
      8,
      f
    );
  }
};


/**
 * optional uint64 amt = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getAmt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setAmt = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional bytes pubkey = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes pubkey = 3;
 * This is a type-conversion wrapper around `getPubkey()`
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPubkey()));
};


/**
 * optional bytes pubkey = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPubkey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPubkey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setPubkey = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes last_hop = 4;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getLastHop = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes last_hop = 4;
 * This is a type-conversion wrapper around `getLastHop()`
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getLastHop_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastHop()));
};


/**
 * optional bytes last_hop = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastHop()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getLastHop_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastHop()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setLastHop = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * repeated RouteHint route_hints = 5;
 * @return {!Array<!proto.looprpc.RouteHint>}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getRouteHintsList = function() {
  return /** @type{!Array<!proto.looprpc.RouteHint>} */ (
    jspb.Message.getRepeatedWrapperField(this, swapserverrpc_common_pb.RouteHint, 5));
};


/**
 * @param {!Array<!proto.looprpc.RouteHint>} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
*/
proto.looprpc.ServerLoopInQuoteRequest.prototype.setRouteHintsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.looprpc.RouteHint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.looprpc.RouteHint}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.addRouteHints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.looprpc.RouteHint, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.clearRouteHintsList = function() {
  return this.setRouteHintsList([]);
};


/**
 * optional ProtocolVersion protocol_version = 2;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional string user_agent = 6;
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getUserAgent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setUserAgent = function(value) {
  return jspb.Message.setProto3StringField(this, 6, value);
};


/**
 * optional uint32 num_static_address_deposits = 7;
 * @return {number}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getNumStaticAddressDeposits = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setNumStaticAddressDeposits = function(value) {
  return jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional bool fast = 8;
 * @return {boolean}
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.getFast = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 8, false));
};


/**
 * @param {boolean} value
 * @return {!proto.looprpc.ServerLoopInQuoteRequest} returns this
 */
proto.looprpc.ServerLoopInQuoteRequest.prototype.setFast = function(value) {
  return jspb.Message.setProto3BooleanField(this, 8, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopInQuoteResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopInQuoteResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInQuoteResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    swapFee: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    swapFeeRate: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    minSwapAmount: jspb.Message.getFieldWithDefault(msg, 4, "0"),
    maxSwapAmount: jspb.Message.getFieldWithDefault(msg, 5, "0"),
    cltvDelta: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopInQuoteResponse}
 */
proto.looprpc.ServerLoopInQuoteResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopInQuoteResponse;
  return proto.looprpc.ServerLoopInQuoteResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopInQuoteResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopInQuoteResponse}
 */
proto.looprpc.ServerLoopInQuoteResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setSwapFee(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setSwapFeeRate(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMinSwapAmount(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMaxSwapAmount(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setCltvDelta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopInQuoteResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopInQuoteResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInQuoteResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSwapFee();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      1,
      f
    );
  }
  f = message.getSwapFeeRate();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      2,
      f
    );
  }
  f = message.getMinSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      4,
      f
    );
  }
  f = message.getMaxSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      5,
      f
    );
  }
  f = message.getCltvDelta();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
};


/**
 * optional int64 swap_fee = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.getSwapFee = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInQuoteResponse} returns this
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.setSwapFee = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional int64 swap_fee_rate = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.getSwapFeeRate = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInQuoteResponse} returns this
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.setSwapFeeRate = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};


/**
 * optional uint64 min_swap_amount = 4;
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.getMinSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInQuoteResponse} returns this
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.setMinSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 4, value);
};


/**
 * optional uint64 max_swap_amount = 5;
 * @return {string}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.getMaxSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInQuoteResponse} returns this
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.setMaxSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 5, value);
};


/**
 * optional int32 cltv_delta = 6;
 * @return {number}
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.getCltvDelta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ServerLoopInQuoteResponse} returns this
 */
proto.looprpc.ServerLoopInQuoteResponse.prototype.setCltvDelta = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopInTermsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopInTermsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopInTermsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInTermsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    userAgent: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopInTermsRequest}
 */
proto.looprpc.ServerLoopInTermsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopInTermsRequest;
  return proto.looprpc.ServerLoopInTermsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopInTermsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopInTermsRequest}
 */
proto.looprpc.ServerLoopInTermsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserAgent(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInTermsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopInTermsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopInTermsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInTermsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getUserAgent();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopInTermsRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopInTermsRequest} returns this
 */
proto.looprpc.ServerLoopInTermsRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional string user_agent = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopInTermsRequest.prototype.getUserAgent = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInTermsRequest} returns this
 */
proto.looprpc.ServerLoopInTermsRequest.prototype.setUserAgent = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopInTerms.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopInTerms.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopInTerms} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInTerms.toObject = function(includeInstance, msg) {
  var f, obj = {
    minSwapAmount: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    maxSwapAmount: jspb.Message.getFieldWithDefault(msg, 2, "0")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopInTerms}
 */
proto.looprpc.ServerLoopInTerms.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopInTerms;
  return proto.looprpc.ServerLoopInTerms.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopInTerms} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopInTerms}
 */
proto.looprpc.ServerLoopInTerms.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMinSwapAmount(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setMaxSwapAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopInTerms.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopInTerms.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopInTerms} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopInTerms.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMinSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getMaxSwapAmount();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      2,
      f
    );
  }
};


/**
 * optional uint64 min_swap_amount = 1;
 * @return {string}
 */
proto.looprpc.ServerLoopInTerms.prototype.getMinSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInTerms} returns this
 */
proto.looprpc.ServerLoopInTerms.prototype.setMinSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional uint64 max_swap_amount = 2;
 * @return {string}
 */
proto.looprpc.ServerLoopInTerms.prototype.getMaxSwapAmount = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerLoopInTerms} returns this
 */
proto.looprpc.ServerLoopInTerms.prototype.setMaxSwapAmount = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutPushPreimageRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutPushPreimageRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    preimage: msg.getPreimage_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutPushPreimageRequest}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutPushPreimageRequest;
  return proto.looprpc.ServerLoopOutPushPreimageRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutPushPreimageRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutPushPreimageRequest}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPreimage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutPushPreimageRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutPushPreimageRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPreimage_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerLoopOutPushPreimageRequest} returns this
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes preimage = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.getPreimage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes preimage = 2;
 * This is a type-conversion wrapper around `getPreimage()`
 * @return {string}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.getPreimage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPreimage()));
};


/**
 * optional bytes preimage = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPreimage()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.getPreimage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPreimage()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerLoopOutPushPreimageRequest} returns this
 */
proto.looprpc.ServerLoopOutPushPreimageRequest.prototype.setPreimage = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerLoopOutPushPreimageResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerLoopOutPushPreimageResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerLoopOutPushPreimageResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutPushPreimageResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerLoopOutPushPreimageResponse}
 */
proto.looprpc.ServerLoopOutPushPreimageResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerLoopOutPushPreimageResponse;
  return proto.looprpc.ServerLoopOutPushPreimageResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerLoopOutPushPreimageResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerLoopOutPushPreimageResponse}
 */
proto.looprpc.ServerLoopOutPushPreimageResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerLoopOutPushPreimageResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerLoopOutPushPreimageResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerLoopOutPushPreimageResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerLoopOutPushPreimageResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.SubscribeUpdatesRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.SubscribeUpdatesRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeUpdatesRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    swapHash: msg.getSwapHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.SubscribeUpdatesRequest}
 */
proto.looprpc.SubscribeUpdatesRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.SubscribeUpdatesRequest;
  return proto.looprpc.SubscribeUpdatesRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.SubscribeUpdatesRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.SubscribeUpdatesRequest}
 */
proto.looprpc.SubscribeUpdatesRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.SubscribeUpdatesRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.SubscribeUpdatesRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeUpdatesRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.SubscribeUpdatesRequest} returns this
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.SubscribeUpdatesRequest} returns this
 */
proto.looprpc.SubscribeUpdatesRequest.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.SubscribeLoopOutUpdatesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.SubscribeLoopOutUpdatesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    timestampNs: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    state: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.SubscribeLoopOutUpdatesResponse}
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.SubscribeLoopOutUpdatesResponse;
  return proto.looprpc.SubscribeLoopOutUpdatesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.SubscribeLoopOutUpdatesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.SubscribeLoopOutUpdatesResponse}
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setTimestampNs(value);
      break;
    case 2:
      var value = /** @type {!proto.looprpc.ServerSwapState} */ (reader.readEnum());
      msg.setState(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.SubscribeLoopOutUpdatesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.SubscribeLoopOutUpdatesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTimestampNs();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      1,
      f
    );
  }
  f = message.getState();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * optional int64 timestamp_ns = 1;
 * @return {string}
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.prototype.getTimestampNs = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.SubscribeLoopOutUpdatesResponse} returns this
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.prototype.setTimestampNs = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional ServerSwapState state = 2;
 * @return {!proto.looprpc.ServerSwapState}
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.prototype.getState = function() {
  return /** @type {!proto.looprpc.ServerSwapState} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.looprpc.ServerSwapState} value
 * @return {!proto.looprpc.SubscribeLoopOutUpdatesResponse} returns this
 */
proto.looprpc.SubscribeLoopOutUpdatesResponse.prototype.setState = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.SubscribeLoopInUpdatesResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.SubscribeLoopInUpdatesResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    timestampNs: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    state: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.SubscribeLoopInUpdatesResponse}
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.SubscribeLoopInUpdatesResponse;
  return proto.looprpc.SubscribeLoopInUpdatesResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.SubscribeLoopInUpdatesResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.SubscribeLoopInUpdatesResponse}
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setTimestampNs(value);
      break;
    case 2:
      var value = /** @type {!proto.looprpc.ServerSwapState} */ (reader.readEnum());
      msg.setState(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.SubscribeLoopInUpdatesResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.SubscribeLoopInUpdatesResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTimestampNs();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      1,
      f
    );
  }
  f = message.getState();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * optional int64 timestamp_ns = 1;
 * @return {string}
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.prototype.getTimestampNs = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.SubscribeLoopInUpdatesResponse} returns this
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.prototype.setTimestampNs = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional ServerSwapState state = 2;
 * @return {!proto.looprpc.ServerSwapState}
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.prototype.getState = function() {
  return /** @type {!proto.looprpc.ServerSwapState} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.looprpc.ServerSwapState} value
 * @return {!proto.looprpc.SubscribeLoopInUpdatesResponse} returns this
 */
proto.looprpc.SubscribeLoopInUpdatesResponse.prototype.setState = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.looprpc.RouteCancel.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.RouteCancel.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.RouteCancel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.RouteCancel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.RouteCancel.toObject = function(includeInstance, msg) {
  var f, obj = {
    routeType: jspb.Message.getFieldWithDefault(msg, 1, 0),
    attemptsList: jspb.Message.toObjectList(msg.getAttemptsList(),
    proto.looprpc.HtlcAttempt.toObject, includeInstance),
    failure: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.RouteCancel}
 */
proto.looprpc.RouteCancel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.RouteCancel;
  return proto.looprpc.RouteCancel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.RouteCancel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.RouteCancel}
 */
proto.looprpc.RouteCancel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.RoutePaymentType} */ (reader.readEnum());
      msg.setRouteType(value);
      break;
    case 2:
      var value = new proto.looprpc.HtlcAttempt;
      reader.readMessage(value,proto.looprpc.HtlcAttempt.deserializeBinaryFromReader);
      msg.addAttempts(value);
      break;
    case 3:
      var value = /** @type {!proto.looprpc.PaymentFailureReason} */ (reader.readEnum());
      msg.setFailure(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.RouteCancel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.RouteCancel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.RouteCancel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.RouteCancel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRouteType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getAttemptsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.looprpc.HtlcAttempt.serializeBinaryToWriter
    );
  }
  f = message.getFailure();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
};


/**
 * optional RoutePaymentType route_type = 1;
 * @return {!proto.looprpc.RoutePaymentType}
 */
proto.looprpc.RouteCancel.prototype.getRouteType = function() {
  return /** @type {!proto.looprpc.RoutePaymentType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.RoutePaymentType} value
 * @return {!proto.looprpc.RouteCancel} returns this
 */
proto.looprpc.RouteCancel.prototype.setRouteType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * repeated HtlcAttempt attempts = 2;
 * @return {!Array<!proto.looprpc.HtlcAttempt>}
 */
proto.looprpc.RouteCancel.prototype.getAttemptsList = function() {
  return /** @type{!Array<!proto.looprpc.HtlcAttempt>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.looprpc.HtlcAttempt, 2));
};


/**
 * @param {!Array<!proto.looprpc.HtlcAttempt>} value
 * @return {!proto.looprpc.RouteCancel} returns this
*/
proto.looprpc.RouteCancel.prototype.setAttemptsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.looprpc.HtlcAttempt=} opt_value
 * @param {number=} opt_index
 * @return {!proto.looprpc.HtlcAttempt}
 */
proto.looprpc.RouteCancel.prototype.addAttempts = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.looprpc.HtlcAttempt, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.looprpc.RouteCancel} returns this
 */
proto.looprpc.RouteCancel.prototype.clearAttemptsList = function() {
  return this.setAttemptsList([]);
};


/**
 * optional PaymentFailureReason failure = 3;
 * @return {!proto.looprpc.PaymentFailureReason}
 */
proto.looprpc.RouteCancel.prototype.getFailure = function() {
  return /** @type {!proto.looprpc.PaymentFailureReason} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.looprpc.PaymentFailureReason} value
 * @return {!proto.looprpc.RouteCancel} returns this
 */
proto.looprpc.RouteCancel.prototype.setFailure = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.HtlcAttempt.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.HtlcAttempt.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.HtlcAttempt} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.HtlcAttempt.toObject = function(includeInstance, msg) {
  var f, obj = {
    remainingHops: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.HtlcAttempt}
 */
proto.looprpc.HtlcAttempt.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.HtlcAttempt;
  return proto.looprpc.HtlcAttempt.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.HtlcAttempt} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.HtlcAttempt}
 */
proto.looprpc.HtlcAttempt.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRemainingHops(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.HtlcAttempt.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.HtlcAttempt.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.HtlcAttempt} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.HtlcAttempt.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRemainingHops();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 remaining_hops = 1;
 * @return {number}
 */
proto.looprpc.HtlcAttempt.prototype.getRemainingHops = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.HtlcAttempt} returns this
 */
proto.looprpc.HtlcAttempt.prototype.setRemainingHops = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.looprpc.CancelLoopOutSwapRequest.oneofGroups_ = [[5]];

/**
 * @enum {number}
 */
proto.looprpc.CancelLoopOutSwapRequest.CancelInfoCase = {
  CANCEL_INFO_NOT_SET: 0,
  ROUTE_CANCEL: 5
};

/**
 * @return {proto.looprpc.CancelLoopOutSwapRequest.CancelInfoCase}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getCancelInfoCase = function() {
  return /** @type {proto.looprpc.CancelLoopOutSwapRequest.CancelInfoCase} */(jspb.Message.computeOneofCase(this, proto.looprpc.CancelLoopOutSwapRequest.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.CancelLoopOutSwapRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.CancelLoopOutSwapRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.CancelLoopOutSwapRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    swapHash: msg.getSwapHash_asB64(),
    paymentAddress: msg.getPaymentAddress_asB64(),
    routeCancel: (f = msg.getRouteCancel()) && proto.looprpc.RouteCancel.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.CancelLoopOutSwapRequest}
 */
proto.looprpc.CancelLoopOutSwapRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.CancelLoopOutSwapRequest;
  return proto.looprpc.CancelLoopOutSwapRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.CancelLoopOutSwapRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.CancelLoopOutSwapRequest}
 */
proto.looprpc.CancelLoopOutSwapRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentAddress(value);
      break;
    case 5:
      var value = new proto.looprpc.RouteCancel;
      reader.readMessage(value,proto.looprpc.RouteCancel.deserializeBinaryFromReader);
      msg.setRouteCancel(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.CancelLoopOutSwapRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.CancelLoopOutSwapRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.CancelLoopOutSwapRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPaymentAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getRouteCancel();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.looprpc.RouteCancel.serializeBinaryToWriter
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.CancelLoopOutSwapRequest} returns this
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.CancelLoopOutSwapRequest} returns this
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes payment_address = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getPaymentAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payment_address = 3;
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {string}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getPaymentAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentAddress()));
};


/**
 * optional bytes payment_address = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {!Uint8Array}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getPaymentAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentAddress()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.CancelLoopOutSwapRequest} returns this
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.setPaymentAddress = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional RouteCancel route_cancel = 5;
 * @return {?proto.looprpc.RouteCancel}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.getRouteCancel = function() {
  return /** @type{?proto.looprpc.RouteCancel} */ (
    jspb.Message.getWrapperField(this, proto.looprpc.RouteCancel, 5));
};


/**
 * @param {?proto.looprpc.RouteCancel|undefined} value
 * @return {!proto.looprpc.CancelLoopOutSwapRequest} returns this
*/
proto.looprpc.CancelLoopOutSwapRequest.prototype.setRouteCancel = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.looprpc.CancelLoopOutSwapRequest.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.looprpc.CancelLoopOutSwapRequest} returns this
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.clearRouteCancel = function() {
  return this.setRouteCancel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.looprpc.CancelLoopOutSwapRequest.prototype.hasRouteCancel = function() {
  return jspb.Message.getField(this, 5) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.CancelLoopOutSwapResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.CancelLoopOutSwapResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.CancelLoopOutSwapResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.CancelLoopOutSwapResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.CancelLoopOutSwapResponse}
 */
proto.looprpc.CancelLoopOutSwapResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.CancelLoopOutSwapResponse;
  return proto.looprpc.CancelLoopOutSwapResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.CancelLoopOutSwapResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.CancelLoopOutSwapResponse}
 */
proto.looprpc.CancelLoopOutSwapResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.CancelLoopOutSwapResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.CancelLoopOutSwapResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.CancelLoopOutSwapResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.CancelLoopOutSwapResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.looprpc.ServerProbeRequest.repeatedFields_ = [5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerProbeRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerProbeRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerProbeRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerProbeRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    amt: jspb.Message.getFieldWithDefault(msg, 2, "0"),
    target: msg.getTarget_asB64(),
    lastHop: msg.getLastHop_asB64(),
    routeHintsList: jspb.Message.toObjectList(msg.getRouteHintsList(),
    swapserverrpc_common_pb.RouteHint.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerProbeRequest}
 */
proto.looprpc.ServerProbeRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerProbeRequest;
  return proto.looprpc.ServerProbeRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerProbeRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerProbeRequest}
 */
proto.looprpc.ServerProbeRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setAmt(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTarget(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLastHop(value);
      break;
    case 5:
      var value = new swapserverrpc_common_pb.RouteHint;
      reader.readMessage(value,swapserverrpc_common_pb.RouteHint.deserializeBinaryFromReader);
      msg.addRouteHints(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerProbeRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerProbeRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerProbeRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerProbeRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getAmt();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      2,
      f
    );
  }
  f = message.getTarget_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getLastHop_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getRouteHintsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      swapserverrpc_common_pb.RouteHint.serializeBinaryToWriter
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerProbeRequest.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerProbeRequest} returns this
 */
proto.looprpc.ServerProbeRequest.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional uint64 amt = 2;
 * @return {string}
 */
proto.looprpc.ServerProbeRequest.prototype.getAmt = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ServerProbeRequest} returns this
 */
proto.looprpc.ServerProbeRequest.prototype.setAmt = function(value) {
  return jspb.Message.setProto3StringIntField(this, 2, value);
};


/**
 * optional bytes target = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerProbeRequest.prototype.getTarget = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes target = 3;
 * This is a type-conversion wrapper around `getTarget()`
 * @return {string}
 */
proto.looprpc.ServerProbeRequest.prototype.getTarget_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTarget()));
};


/**
 * optional bytes target = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTarget()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerProbeRequest.prototype.getTarget_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTarget()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerProbeRequest} returns this
 */
proto.looprpc.ServerProbeRequest.prototype.setTarget = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes last_hop = 4;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerProbeRequest.prototype.getLastHop = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes last_hop = 4;
 * This is a type-conversion wrapper around `getLastHop()`
 * @return {string}
 */
proto.looprpc.ServerProbeRequest.prototype.getLastHop_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLastHop()));
};


/**
 * optional bytes last_hop = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLastHop()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerProbeRequest.prototype.getLastHop_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLastHop()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerProbeRequest} returns this
 */
proto.looprpc.ServerProbeRequest.prototype.setLastHop = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * repeated RouteHint route_hints = 5;
 * @return {!Array<!proto.looprpc.RouteHint>}
 */
proto.looprpc.ServerProbeRequest.prototype.getRouteHintsList = function() {
  return /** @type{!Array<!proto.looprpc.RouteHint>} */ (
    jspb.Message.getRepeatedWrapperField(this, swapserverrpc_common_pb.RouteHint, 5));
};


/**
 * @param {!Array<!proto.looprpc.RouteHint>} value
 * @return {!proto.looprpc.ServerProbeRequest} returns this
*/
proto.looprpc.ServerProbeRequest.prototype.setRouteHintsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.looprpc.RouteHint=} opt_value
 * @param {number=} opt_index
 * @return {!proto.looprpc.RouteHint}
 */
proto.looprpc.ServerProbeRequest.prototype.addRouteHints = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.looprpc.RouteHint, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.looprpc.ServerProbeRequest} returns this
 */
proto.looprpc.ServerProbeRequest.prototype.clearRouteHintsList = function() {
  return this.setRouteHintsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerProbeResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerProbeResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerProbeResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerProbeResponse.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerProbeResponse}
 */
proto.looprpc.ServerProbeResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerProbeResponse;
  return proto.looprpc.ServerProbeResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerProbeResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerProbeResponse}
 */
proto.looprpc.ServerProbeResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerProbeResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerProbeResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerProbeResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerProbeResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.RecommendRoutingPluginReq.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.RecommendRoutingPluginReq} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.RecommendRoutingPluginReq.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    swapHash: msg.getSwapHash_asB64(),
    paymentAddress: msg.getPaymentAddress_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.RecommendRoutingPluginReq}
 */
proto.looprpc.RecommendRoutingPluginReq.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.RecommendRoutingPluginReq;
  return proto.looprpc.RecommendRoutingPluginReq.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.RecommendRoutingPluginReq} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.RecommendRoutingPluginReq}
 */
proto.looprpc.RecommendRoutingPluginReq.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.RecommendRoutingPluginReq.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.RecommendRoutingPluginReq} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.RecommendRoutingPluginReq.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPaymentAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.RecommendRoutingPluginReq} returns this
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.RecommendRoutingPluginReq} returns this
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes payment_address = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getPaymentAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payment_address = 3;
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {string}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getPaymentAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentAddress()));
};


/**
 * optional bytes payment_address = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {!Uint8Array}
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.getPaymentAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentAddress()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.RecommendRoutingPluginReq} returns this
 */
proto.looprpc.RecommendRoutingPluginReq.prototype.setPaymentAddress = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.RecommendRoutingPluginRes.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.RecommendRoutingPluginRes.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.RecommendRoutingPluginRes} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.RecommendRoutingPluginRes.toObject = function(includeInstance, msg) {
  var f, obj = {
    plugin: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.RecommendRoutingPluginRes}
 */
proto.looprpc.RecommendRoutingPluginRes.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.RecommendRoutingPluginRes;
  return proto.looprpc.RecommendRoutingPluginRes.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.RecommendRoutingPluginRes} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.RecommendRoutingPluginRes}
 */
proto.looprpc.RecommendRoutingPluginRes.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.RoutingPlugin} */ (reader.readEnum());
      msg.setPlugin(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.RecommendRoutingPluginRes.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.RecommendRoutingPluginRes.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.RecommendRoutingPluginRes} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.RecommendRoutingPluginRes.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPlugin();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * optional RoutingPlugin plugin = 1;
 * @return {!proto.looprpc.RoutingPlugin}
 */
proto.looprpc.RecommendRoutingPluginRes.prototype.getPlugin = function() {
  return /** @type {!proto.looprpc.RoutingPlugin} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.RoutingPlugin} value
 * @return {!proto.looprpc.RecommendRoutingPluginRes} returns this
 */
proto.looprpc.RecommendRoutingPluginRes.prototype.setPlugin = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ReportRoutingResultReq.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ReportRoutingResultReq.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ReportRoutingResultReq} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ReportRoutingResultReq.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    swapHash: msg.getSwapHash_asB64(),
    paymentAddress: msg.getPaymentAddress_asB64(),
    plugin: jspb.Message.getFieldWithDefault(msg, 4, 0),
    success: jspb.Message.getBooleanFieldWithDefault(msg, 5, false),
    attempts: jspb.Message.getFieldWithDefault(msg, 6, 0),
    totalTime: jspb.Message.getFieldWithDefault(msg, 7, "0")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ReportRoutingResultReq}
 */
proto.looprpc.ReportRoutingResultReq.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ReportRoutingResultReq;
  return proto.looprpc.ReportRoutingResultReq.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ReportRoutingResultReq} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ReportRoutingResultReq}
 */
proto.looprpc.ReportRoutingResultReq.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentAddress(value);
      break;
    case 4:
      var value = /** @type {!proto.looprpc.RoutingPlugin} */ (reader.readEnum());
      msg.setPlugin(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSuccess(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setAttempts(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readInt64String());
      msg.setTotalTime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ReportRoutingResultReq.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ReportRoutingResultReq.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ReportRoutingResultReq} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ReportRoutingResultReq.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPaymentAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getPlugin();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getSuccess();
  if (f) {
    writer.writeBool(
      5,
      f
    );
  }
  f = message.getAttempts();
  if (f !== 0) {
    writer.writeInt32(
      6,
      f
    );
  }
  f = message.getTotalTime();
  if (parseInt(f, 10) !== 0) {
    writer.writeInt64String(
      7,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes payment_address = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getPaymentAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payment_address = 3;
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {string}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getPaymentAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentAddress()));
};


/**
 * optional bytes payment_address = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {!Uint8Array}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getPaymentAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentAddress()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setPaymentAddress = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional RoutingPlugin plugin = 4;
 * @return {!proto.looprpc.RoutingPlugin}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getPlugin = function() {
  return /** @type {!proto.looprpc.RoutingPlugin} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {!proto.looprpc.RoutingPlugin} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setPlugin = function(value) {
  return jspb.Message.setProto3EnumField(this, 4, value);
};


/**
 * optional bool success = 5;
 * @return {boolean}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getSuccess = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 5, false));
};


/**
 * @param {boolean} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setSuccess = function(value) {
  return jspb.Message.setProto3BooleanField(this, 5, value);
};


/**
 * optional int32 attempts = 6;
 * @return {number}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getAttempts = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setAttempts = function(value) {
  return jspb.Message.setProto3IntField(this, 6, value);
};


/**
 * optional int64 total_time = 7;
 * @return {string}
 */
proto.looprpc.ReportRoutingResultReq.prototype.getTotalTime = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.ReportRoutingResultReq} returns this
 */
proto.looprpc.ReportRoutingResultReq.prototype.setTotalTime = function(value) {
  return jspb.Message.setProto3StringIntField(this, 7, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ReportRoutingResultRes.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ReportRoutingResultRes.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ReportRoutingResultRes} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ReportRoutingResultRes.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ReportRoutingResultRes}
 */
proto.looprpc.ReportRoutingResultRes.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ReportRoutingResultRes;
  return proto.looprpc.ReportRoutingResultRes.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ReportRoutingResultRes} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ReportRoutingResultRes}
 */
proto.looprpc.ReportRoutingResultRes.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ReportRoutingResultRes.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ReportRoutingResultRes.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ReportRoutingResultRes} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ReportRoutingResultRes.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.looprpc.MuSig2SignSweepReq.repeatedFields_ = [7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.MuSig2SignSweepReq.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.MuSig2SignSweepReq} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.MuSig2SignSweepReq.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    swapHash: msg.getSwapHash_asB64(),
    paymentAddress: msg.getPaymentAddress_asB64(),
    nonce: msg.getNonce_asB64(),
    sweepTxPsbt: msg.getSweepTxPsbt_asB64(),
    prevoutInfoList: jspb.Message.toObjectList(msg.getPrevoutInfoList(),
    proto.looprpc.PrevoutInfo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.MuSig2SignSweepReq}
 */
proto.looprpc.MuSig2SignSweepReq.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.MuSig2SignSweepReq;
  return proto.looprpc.MuSig2SignSweepReq.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.MuSig2SignSweepReq} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.MuSig2SignSweepReq}
 */
proto.looprpc.MuSig2SignSweepReq.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPaymentAddress(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNonce(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSweepTxPsbt(value);
      break;
    case 7:
      var value = new proto.looprpc.PrevoutInfo;
      reader.readMessage(value,proto.looprpc.PrevoutInfo.deserializeBinaryFromReader);
      msg.addPrevoutInfo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.MuSig2SignSweepReq.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.MuSig2SignSweepReq} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.MuSig2SignSweepReq.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getPaymentAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getNonce_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = message.getSweepTxPsbt_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = message.getPrevoutInfoList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.looprpc.PrevoutInfo.serializeBinaryToWriter
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
 */
proto.looprpc.MuSig2SignSweepReq.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
 */
proto.looprpc.MuSig2SignSweepReq.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes payment_address = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getPaymentAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes payment_address = 3;
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {string}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getPaymentAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPaymentAddress()));
};


/**
 * optional bytes payment_address = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPaymentAddress()`
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getPaymentAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPaymentAddress()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
 */
proto.looprpc.MuSig2SignSweepReq.prototype.setPaymentAddress = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes nonce = 4;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getNonce = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes nonce = 4;
 * This is a type-conversion wrapper around `getNonce()`
 * @return {string}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getNonce_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNonce()));
};


/**
 * optional bytes nonce = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNonce()`
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getNonce_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNonce()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
 */
proto.looprpc.MuSig2SignSweepReq.prototype.setNonce = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};


/**
 * optional bytes sweep_tx_psbt = 6;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getSweepTxPsbt = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes sweep_tx_psbt = 6;
 * This is a type-conversion wrapper around `getSweepTxPsbt()`
 * @return {string}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getSweepTxPsbt_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSweepTxPsbt()));
};


/**
 * optional bytes sweep_tx_psbt = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSweepTxPsbt()`
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getSweepTxPsbt_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSweepTxPsbt()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
 */
proto.looprpc.MuSig2SignSweepReq.prototype.setSweepTxPsbt = function(value) {
  return jspb.Message.setProto3BytesField(this, 6, value);
};


/**
 * repeated PrevoutInfo prevout_info = 7;
 * @return {!Array<!proto.looprpc.PrevoutInfo>}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.getPrevoutInfoList = function() {
  return /** @type{!Array<!proto.looprpc.PrevoutInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.looprpc.PrevoutInfo, 7));
};


/**
 * @param {!Array<!proto.looprpc.PrevoutInfo>} value
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
*/
proto.looprpc.MuSig2SignSweepReq.prototype.setPrevoutInfoList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.looprpc.PrevoutInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.looprpc.PrevoutInfo}
 */
proto.looprpc.MuSig2SignSweepReq.prototype.addPrevoutInfo = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.looprpc.PrevoutInfo, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.looprpc.MuSig2SignSweepReq} returns this
 */
proto.looprpc.MuSig2SignSweepReq.prototype.clearPrevoutInfoList = function() {
  return this.setPrevoutInfoList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.PrevoutInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.PrevoutInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.PrevoutInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.PrevoutInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFieldWithDefault(msg, 1, "0"),
    pkScript: msg.getPkScript_asB64(),
    txidBytes: msg.getTxidBytes_asB64(),
    outputIndex: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.PrevoutInfo}
 */
proto.looprpc.PrevoutInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.PrevoutInfo;
  return proto.looprpc.PrevoutInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.PrevoutInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.PrevoutInfo}
 */
proto.looprpc.PrevoutInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readUint64String());
      msg.setValue(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPkScript(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTxidBytes(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.PrevoutInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.PrevoutInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.PrevoutInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.PrevoutInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (parseInt(f, 10) !== 0) {
    writer.writeUint64String(
      1,
      f
    );
  }
  f = message.getPkScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getTxidBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getOutputIndex();
  if (f !== 0) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional uint64 value = 1;
 * @return {string}
 */
proto.looprpc.PrevoutInfo.prototype.getValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, "0"));
};


/**
 * @param {string} value
 * @return {!proto.looprpc.PrevoutInfo} returns this
 */
proto.looprpc.PrevoutInfo.prototype.setValue = function(value) {
  return jspb.Message.setProto3StringIntField(this, 1, value);
};


/**
 * optional bytes pk_script = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.PrevoutInfo.prototype.getPkScript = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes pk_script = 2;
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {string}
 */
proto.looprpc.PrevoutInfo.prototype.getPkScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPkScript()));
};


/**
 * optional bytes pk_script = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPkScript()`
 * @return {!Uint8Array}
 */
proto.looprpc.PrevoutInfo.prototype.getPkScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPkScript()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.PrevoutInfo} returns this
 */
proto.looprpc.PrevoutInfo.prototype.setPkScript = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes txid_bytes = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.PrevoutInfo.prototype.getTxidBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes txid_bytes = 3;
 * This is a type-conversion wrapper around `getTxidBytes()`
 * @return {string}
 */
proto.looprpc.PrevoutInfo.prototype.getTxidBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTxidBytes()));
};


/**
 * optional bytes txid_bytes = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxidBytes()`
 * @return {!Uint8Array}
 */
proto.looprpc.PrevoutInfo.prototype.getTxidBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTxidBytes()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.PrevoutInfo} returns this
 */
proto.looprpc.PrevoutInfo.prototype.setTxidBytes = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional uint32 output_index = 4;
 * @return {number}
 */
proto.looprpc.PrevoutInfo.prototype.getOutputIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.looprpc.PrevoutInfo} returns this
 */
proto.looprpc.PrevoutInfo.prototype.setOutputIndex = function(value) {
  return jspb.Message.setProto3IntField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.MuSig2SignSweepRes.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.MuSig2SignSweepRes} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.MuSig2SignSweepRes.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: msg.getNonce_asB64(),
    partialSignature: msg.getPartialSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.MuSig2SignSweepRes}
 */
proto.looprpc.MuSig2SignSweepRes.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.MuSig2SignSweepRes;
  return proto.looprpc.MuSig2SignSweepRes.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.MuSig2SignSweepRes} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.MuSig2SignSweepRes}
 */
proto.looprpc.MuSig2SignSweepRes.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPartialSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.MuSig2SignSweepRes.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.MuSig2SignSweepRes} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.MuSig2SignSweepRes.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNonce_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getPartialSignature_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes nonce = 1;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.getNonce = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes nonce = 1;
 * This is a type-conversion wrapper around `getNonce()`
 * @return {string}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.getNonce_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNonce()));
};


/**
 * optional bytes nonce = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNonce()`
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.getNonce_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNonce()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.MuSig2SignSweepRes} returns this
 */
proto.looprpc.MuSig2SignSweepRes.prototype.setNonce = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes partial_signature = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.getPartialSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes partial_signature = 2;
 * This is a type-conversion wrapper around `getPartialSignature()`
 * @return {string}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.getPartialSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPartialSignature()));
};


/**
 * optional bytes partial_signature = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPartialSignature()`
 * @return {!Uint8Array}
 */
proto.looprpc.MuSig2SignSweepRes.prototype.getPartialSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPartialSignature()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.MuSig2SignSweepRes} returns this
 */
proto.looprpc.MuSig2SignSweepRes.prototype.setPartialSignature = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerPushKeyReq.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerPushKeyReq.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerPushKeyReq} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerPushKeyReq.toObject = function(includeInstance, msg) {
  var f, obj = {
    protocolVersion: jspb.Message.getFieldWithDefault(msg, 1, 0),
    swapHash: msg.getSwapHash_asB64(),
    internalPrivkey: msg.getInternalPrivkey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerPushKeyReq}
 */
proto.looprpc.ServerPushKeyReq.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerPushKeyReq;
  return proto.looprpc.ServerPushKeyReq.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerPushKeyReq} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerPushKeyReq}
 */
proto.looprpc.ServerPushKeyReq.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.ProtocolVersion} */ (reader.readEnum());
      msg.setProtocolVersion(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setInternalPrivkey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerPushKeyReq.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerPushKeyReq.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerPushKeyReq} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerPushKeyReq.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getProtocolVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getInternalPrivkey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional ProtocolVersion protocol_version = 1;
 * @return {!proto.looprpc.ProtocolVersion}
 */
proto.looprpc.ServerPushKeyReq.prototype.getProtocolVersion = function() {
  return /** @type {!proto.looprpc.ProtocolVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.ProtocolVersion} value
 * @return {!proto.looprpc.ServerPushKeyReq} returns this
 */
proto.looprpc.ServerPushKeyReq.prototype.setProtocolVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerPushKeyReq.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.ServerPushKeyReq.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerPushKeyReq.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerPushKeyReq} returns this
 */
proto.looprpc.ServerPushKeyReq.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes internal_privkey = 3;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerPushKeyReq.prototype.getInternalPrivkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes internal_privkey = 3;
 * This is a type-conversion wrapper around `getInternalPrivkey()`
 * @return {string}
 */
proto.looprpc.ServerPushKeyReq.prototype.getInternalPrivkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getInternalPrivkey()));
};


/**
 * optional bytes internal_privkey = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getInternalPrivkey()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerPushKeyReq.prototype.getInternalPrivkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getInternalPrivkey()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerPushKeyReq} returns this
 */
proto.looprpc.ServerPushKeyReq.prototype.setInternalPrivkey = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerPushKeyRes.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerPushKeyRes.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerPushKeyRes} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerPushKeyRes.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerPushKeyRes}
 */
proto.looprpc.ServerPushKeyRes.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerPushKeyRes;
  return proto.looprpc.ServerPushKeyRes.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerPushKeyRes} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerPushKeyRes}
 */
proto.looprpc.ServerPushKeyRes.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerPushKeyRes.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerPushKeyRes.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerPushKeyRes} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerPushKeyRes.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.FetchL402Request.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.FetchL402Request.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.FetchL402Request} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.FetchL402Request.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.FetchL402Request}
 */
proto.looprpc.FetchL402Request.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.FetchL402Request;
  return proto.looprpc.FetchL402Request.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.FetchL402Request} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.FetchL402Request}
 */
proto.looprpc.FetchL402Request.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.FetchL402Request.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.FetchL402Request.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.FetchL402Request} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.FetchL402Request.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.FetchL402Response.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.FetchL402Response.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.FetchL402Response} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.FetchL402Response.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.FetchL402Response}
 */
proto.looprpc.FetchL402Response.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.FetchL402Response;
  return proto.looprpc.FetchL402Response.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.FetchL402Response} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.FetchL402Response}
 */
proto.looprpc.FetchL402Response.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.FetchL402Response.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.FetchL402Response.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.FetchL402Response} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.FetchL402Response.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.SubscribeNotificationsRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.SubscribeNotificationsRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.SubscribeNotificationsRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeNotificationsRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getFieldWithDefault(msg, 1, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.SubscribeNotificationsRequest}
 */
proto.looprpc.SubscribeNotificationsRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.SubscribeNotificationsRequest;
  return proto.looprpc.SubscribeNotificationsRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.SubscribeNotificationsRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.SubscribeNotificationsRequest}
 */
proto.looprpc.SubscribeNotificationsRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.looprpc.SubscribeNotificationsRequest.ListenerVersion} */ (reader.readEnum());
      msg.setVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.SubscribeNotificationsRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.SubscribeNotificationsRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.SubscribeNotificationsRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeNotificationsRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getVersion();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.looprpc.SubscribeNotificationsRequest.ListenerVersion = {
  LEGACY: 0,
  V1: 1
};

/**
 * optional ListenerVersion version = 1;
 * @return {!proto.looprpc.SubscribeNotificationsRequest.ListenerVersion}
 */
proto.looprpc.SubscribeNotificationsRequest.prototype.getVersion = function() {
  return /** @type {!proto.looprpc.SubscribeNotificationsRequest.ListenerVersion} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.looprpc.SubscribeNotificationsRequest.ListenerVersion} value
 * @return {!proto.looprpc.SubscribeNotificationsRequest} returns this
 */
proto.looprpc.SubscribeNotificationsRequest.prototype.setVersion = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.looprpc.SubscribeNotificationsResponse.oneofGroups_ = [[1,2,3]];

/**
 * @enum {number}
 */
proto.looprpc.SubscribeNotificationsResponse.NotificationCase = {
  NOTIFICATION_NOT_SET: 0,
  RESERVATION_NOTIFICATION: 1,
  STATIC_LOOP_IN_SWEEP: 2,
  UNFINISHED_SWAP: 3
};

/**
 * @return {proto.looprpc.SubscribeNotificationsResponse.NotificationCase}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.getNotificationCase = function() {
  return /** @type {proto.looprpc.SubscribeNotificationsResponse.NotificationCase} */(jspb.Message.computeOneofCase(this, proto.looprpc.SubscribeNotificationsResponse.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.SubscribeNotificationsResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.SubscribeNotificationsResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeNotificationsResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    reservationNotification: (f = msg.getReservationNotification()) && swapserverrpc_reservation_pb.ServerReservationNotification.toObject(includeInstance, f),
    staticLoopInSweep: (f = msg.getStaticLoopInSweep()) && proto.looprpc.ServerStaticLoopInSweepNotification.toObject(includeInstance, f),
    unfinishedSwap: (f = msg.getUnfinishedSwap()) && proto.looprpc.ServerUnfinishedSwapNotification.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.SubscribeNotificationsResponse}
 */
proto.looprpc.SubscribeNotificationsResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.SubscribeNotificationsResponse;
  return proto.looprpc.SubscribeNotificationsResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.SubscribeNotificationsResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.SubscribeNotificationsResponse}
 */
proto.looprpc.SubscribeNotificationsResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new swapserverrpc_reservation_pb.ServerReservationNotification;
      reader.readMessage(value,swapserverrpc_reservation_pb.ServerReservationNotification.deserializeBinaryFromReader);
      msg.setReservationNotification(value);
      break;
    case 2:
      var value = new proto.looprpc.ServerStaticLoopInSweepNotification;
      reader.readMessage(value,proto.looprpc.ServerStaticLoopInSweepNotification.deserializeBinaryFromReader);
      msg.setStaticLoopInSweep(value);
      break;
    case 3:
      var value = new proto.looprpc.ServerUnfinishedSwapNotification;
      reader.readMessage(value,proto.looprpc.ServerUnfinishedSwapNotification.deserializeBinaryFromReader);
      msg.setUnfinishedSwap(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.SubscribeNotificationsResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.SubscribeNotificationsResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.SubscribeNotificationsResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getReservationNotification();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      swapserverrpc_reservation_pb.ServerReservationNotification.serializeBinaryToWriter
    );
  }
  f = message.getStaticLoopInSweep();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.looprpc.ServerStaticLoopInSweepNotification.serializeBinaryToWriter
    );
  }
  f = message.getUnfinishedSwap();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.looprpc.ServerUnfinishedSwapNotification.serializeBinaryToWriter
    );
  }
};


/**
 * optional ServerReservationNotification reservation_notification = 1;
 * @return {?proto.looprpc.ServerReservationNotification}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.getReservationNotification = function() {
  return /** @type{?proto.looprpc.ServerReservationNotification} */ (
    jspb.Message.getWrapperField(this, swapserverrpc_reservation_pb.ServerReservationNotification, 1));
};


/**
 * @param {?proto.looprpc.ServerReservationNotification|undefined} value
 * @return {!proto.looprpc.SubscribeNotificationsResponse} returns this
*/
proto.looprpc.SubscribeNotificationsResponse.prototype.setReservationNotification = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.looprpc.SubscribeNotificationsResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.looprpc.SubscribeNotificationsResponse} returns this
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.clearReservationNotification = function() {
  return this.setReservationNotification(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.hasReservationNotification = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ServerStaticLoopInSweepNotification static_loop_in_sweep = 2;
 * @return {?proto.looprpc.ServerStaticLoopInSweepNotification}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.getStaticLoopInSweep = function() {
  return /** @type{?proto.looprpc.ServerStaticLoopInSweepNotification} */ (
    jspb.Message.getWrapperField(this, proto.looprpc.ServerStaticLoopInSweepNotification, 2));
};


/**
 * @param {?proto.looprpc.ServerStaticLoopInSweepNotification|undefined} value
 * @return {!proto.looprpc.SubscribeNotificationsResponse} returns this
*/
proto.looprpc.SubscribeNotificationsResponse.prototype.setStaticLoopInSweep = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.looprpc.SubscribeNotificationsResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.looprpc.SubscribeNotificationsResponse} returns this
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.clearStaticLoopInSweep = function() {
  return this.setStaticLoopInSweep(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.hasStaticLoopInSweep = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ServerUnfinishedSwapNotification unfinished_swap = 3;
 * @return {?proto.looprpc.ServerUnfinishedSwapNotification}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.getUnfinishedSwap = function() {
  return /** @type{?proto.looprpc.ServerUnfinishedSwapNotification} */ (
    jspb.Message.getWrapperField(this, proto.looprpc.ServerUnfinishedSwapNotification, 3));
};


/**
 * @param {?proto.looprpc.ServerUnfinishedSwapNotification|undefined} value
 * @return {!proto.looprpc.SubscribeNotificationsResponse} returns this
*/
proto.looprpc.SubscribeNotificationsResponse.prototype.setUnfinishedSwap = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.looprpc.SubscribeNotificationsResponse.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.looprpc.SubscribeNotificationsResponse} returns this
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.clearUnfinishedSwap = function() {
  return this.setUnfinishedSwap(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.looprpc.SubscribeNotificationsResponse.prototype.hasUnfinishedSwap = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.looprpc.ServerStaticLoopInSweepNotification.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerStaticLoopInSweepNotification.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerStaticLoopInSweepNotification} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerStaticLoopInSweepNotification.toObject = function(includeInstance, msg) {
  var f, obj = {
    sweepTxPsbt: msg.getSweepTxPsbt_asB64(),
    swapHash: msg.getSwapHash_asB64(),
    depositToNoncesMap: (f = msg.getDepositToNoncesMap()) ? f.toObject(includeInstance, undefined) : [],
    prevoutInfoList: jspb.Message.toObjectList(msg.getPrevoutInfoList(),
    proto.looprpc.PrevoutInfo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerStaticLoopInSweepNotification;
  return proto.looprpc.ServerStaticLoopInSweepNotification.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerStaticLoopInSweepNotification} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSweepTxPsbt(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 3:
      var value = msg.getDepositToNoncesMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readBytes, null, "", "");
         });
      break;
    case 4:
      var value = new proto.looprpc.PrevoutInfo;
      reader.readMessage(value,proto.looprpc.PrevoutInfo.deserializeBinaryFromReader);
      msg.addPrevoutInfo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerStaticLoopInSweepNotification.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerStaticLoopInSweepNotification} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerStaticLoopInSweepNotification.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSweepTxPsbt_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getDepositToNoncesMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(3, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeBytes);
  }
  f = message.getPrevoutInfoList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.looprpc.PrevoutInfo.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes sweep_tx_psbt = 1;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getSweepTxPsbt = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes sweep_tx_psbt = 1;
 * This is a type-conversion wrapper around `getSweepTxPsbt()`
 * @return {string}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getSweepTxPsbt_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSweepTxPsbt()));
};


/**
 * optional bytes sweep_tx_psbt = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSweepTxPsbt()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getSweepTxPsbt_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSweepTxPsbt()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification} returns this
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.setSweepTxPsbt = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes swap_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes swap_hash = 2;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification} returns this
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * map<string, bytes> deposit_to_nonces = 3;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!(string|Uint8Array)>}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getDepositToNoncesMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!(string|Uint8Array)>} */ (
      jspb.Message.getMapField(this, 3, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification} returns this
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.clearDepositToNoncesMap = function() {
  this.getDepositToNoncesMap().clear();
  return this;
};


/**
 * repeated PrevoutInfo prevout_info = 4;
 * @return {!Array<!proto.looprpc.PrevoutInfo>}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.getPrevoutInfoList = function() {
  return /** @type{!Array<!proto.looprpc.PrevoutInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.looprpc.PrevoutInfo, 4));
};


/**
 * @param {!Array<!proto.looprpc.PrevoutInfo>} value
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification} returns this
*/
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.setPrevoutInfoList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.looprpc.PrevoutInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.looprpc.PrevoutInfo}
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.addPrevoutInfo = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.looprpc.PrevoutInfo, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.looprpc.ServerStaticLoopInSweepNotification} returns this
 */
proto.looprpc.ServerStaticLoopInSweepNotification.prototype.clearPrevoutInfoList = function() {
  return this.setPrevoutInfoList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.toObject = function(opt_includeInstance) {
  return proto.looprpc.ServerUnfinishedSwapNotification.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.looprpc.ServerUnfinishedSwapNotification} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerUnfinishedSwapNotification.toObject = function(includeInstance, msg) {
  var f, obj = {
    swapHash: msg.getSwapHash_asB64(),
    isLoopIn: jspb.Message.getBooleanFieldWithDefault(msg, 2, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.looprpc.ServerUnfinishedSwapNotification}
 */
proto.looprpc.ServerUnfinishedSwapNotification.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.looprpc.ServerUnfinishedSwapNotification;
  return proto.looprpc.ServerUnfinishedSwapNotification.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.looprpc.ServerUnfinishedSwapNotification} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.looprpc.ServerUnfinishedSwapNotification}
 */
proto.looprpc.ServerUnfinishedSwapNotification.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSwapHash(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsLoopIn(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.looprpc.ServerUnfinishedSwapNotification.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.looprpc.ServerUnfinishedSwapNotification} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.looprpc.ServerUnfinishedSwapNotification.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSwapHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getIsLoopIn();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional bytes swap_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.getSwapHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes swap_hash = 1;
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {string}
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.getSwapHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSwapHash()));
};


/**
 * optional bytes swap_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSwapHash()`
 * @return {!Uint8Array}
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.getSwapHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSwapHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.looprpc.ServerUnfinishedSwapNotification} returns this
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.setSwapHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bool is_loop_in = 2;
 * @return {boolean}
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.getIsLoopIn = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.looprpc.ServerUnfinishedSwapNotification} returns this
 */
proto.looprpc.ServerUnfinishedSwapNotification.prototype.setIsLoopIn = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * @enum {number}
 */
proto.looprpc.ProtocolVersion = {
  LEGACY: 0,
  MULTI_LOOP_OUT: 1,
  NATIVE_SEGWIT_LOOP_IN: 2,
  PREIMAGE_PUSH_LOOP_OUT: 3,
  USER_EXPIRY_LOOP_OUT: 4,
  HTLC_V2: 5,
  MULTI_LOOP_IN: 6,
  LOOP_OUT_CANCEL: 7,
  PROBE: 8,
  ROUTING_PLUGIN: 9,
  HTLC_V3: 10,
  MUSIG2: 11
};

/**
 * @enum {number}
 */
proto.looprpc.ServerSwapState = {
  SERVER_INITIATED: 0,
  SERVER_HTLC_PUBLISHED: 1,
  SERVER_SUCCESS: 2,
  SERVER_FAILED_UNKNOWN: 3,
  SERVER_FAILED_NO_HTLC: 4,
  SERVER_FAILED_INVALID_HTLC_AMOUNT: 5,
  SERVER_FAILED_OFF_CHAIN_TIMEOUT: 6,
  SERVER_FAILED_TIMEOUT: 7,
  SERVER_FAILED_SWAP_DEADLINE: 8,
  SERVER_FAILED_HTLC_PUBLICATION: 9,
  SERVER_TIMEOUT_PUBLISHED: 10,
  SERVER_UNEXPECTED_FAILURE: 11,
  SERVER_HTLC_CONFIRMED: 12,
  SERVER_CLIENT_PREPAY_CANCEL: 13,
  SERVER_CLIENT_INVOICE_CANCEL: 14,
  SERVER_FAILED_MULTIPLE_SWAP_SCRIPTS: 15,
  SERVER_FAILED_INITIALIZATION: 16
};

/**
 * @enum {number}
 */
proto.looprpc.RoutePaymentType = {
  ROUTE_UNKNOWN: 0,
  PREPAY_ROUTE: 1,
  INVOICE_ROUTE: 2
};

/**
 * @enum {number}
 */
proto.looprpc.PaymentFailureReason = {
  LND_FAILURE_REASON_NONE: 0,
  LND_FAILURE_REASON_TIMEOUT: 1,
  LND_FAILURE_REASON_NO_ROUTE: 2,
  LND_FAILURE_REASON_ERROR: 3,
  LND_FAILURE_REASON_INCORRECT_PAYMENT_DETAILS: 4,
  LND_FAILURE_REASON_INSUFFICIENT_BALANCE: 5
};

/**
 * @enum {number}
 */
proto.looprpc.RoutingPlugin = {
  NONE: 0,
  LOW_HIGH: 1
};

goog.object.extend(exports, proto.looprpc);
